---
title: "cleaning_data"
output: pdf_document
date: "`r Sys.Date()`"
---

```{r}
# load libraries
library(tidyverse)
library(ggplot2)
library(forecast)
library(lubridate)
library(dplyr)
library(astsa)
library(dplyr)
library(lubridate)
library(vars)
library(forecast)
library(tseries)
```

```{r} 
# load data
prices_data <- read_csv("DailyPrices_ICCO.csv", show_col_types=FALSE)
ghana_data <- read_csv("Ghana_data.csv", show_col_types=FALSE)
```


```{r}
clean_ghana <- ghana_data %>%
  mutate(DATE = ymd(DATE)) %>%
  distinct(DATE, .keep_all = TRUE) %>%
  filter(between(DATE, ymd("1994-10-03"), ymd("2024-11-28"))) %>%
  arrange(DATE)
clean_ghana
```


```{r}
total_duplicates <- sum(duplicated(clean_ghana))
total_duplicates
```

```{r}
# select the columns we need (DATE, PRCP, TAVG)
final_ghana <- clean_ghana[, c("DATE", "PRCP", "TAVG")]
final_ghana
```


```{r}
# Load necessary library

# Find rows with duplicated dates
duplicate_dates <- prices_data %>%
  group_by(Date) %>%        # Group by the "Date" column
  filter(n() > 1) %>%       # Keep dates that appear more than once
  arrange(Date) %>%         # Sort by date for clarity
  ungroup()

# Modify the column name from ICCO daily price (US$/tonne) to Price
prices_data <- rename(
  prices_data, 
  Price=`ICCO daily price (US$/tonne)`
)
```

```{r}
# View the results
print(duplicate_dates)

```


```{r}
data <- prices_data %>%
  mutate(Date = ymd(Date)) %>%
  arrange(Date) %>%
  mutate(
    next_price = lead(Price),
    next_date = lead(Date),
    days_diff = as.numeric(next_date - Date),
    price_diff = next_price - Price
  ) %>%
  filter(
    days_diff == 1,          # Strictly consecutive days
    price_diff > 100,        # Price increase > $100
    !is.na(price_diff)       # Remove NA from the last row
  ) %>%
  select(Date, Price, next_date, next_price, price_diff)

# Print results
if (nrow(data) == 0) {
  message("No rows met the criteria.")
} else {
  print(data)
}

```


```{r}
clean_price <- prices_data %>%
  distinct() %>%
  filter(!(Date == "30/01/2024" & `Price` == 10676.42)) %>%
  filter(!(Date == "31/01/2024" & `Price` == 10888.05))
```

```{r}
# Load necessary library

# Find rows with duplicated dates
duplicate_dates <- clean_price %>%
  group_by(Date) %>%        # Group by the "Date" column
  filter(n() > 1) %>%       # Keep dates that appear more than once
  arrange(Date) %>%         # Sort by date for clarity
  ungroup()

print(duplicate_dates)

```


```{r}
final_price <- clean_price[, c("Date", "Price")]
```





```{r}
final_price <- final_price %>%
  mutate(Date = as.Date(Date, format = "%d/%m/%Y"))

final_price

```


```{r}
# Ensure DATE column is already Date type (if not, convert)
final_ghana <- final_ghana %>%
  mutate(Date = as.Date(DATE))

final_ghana
```





```{r}
final_price <- final_price %>%
  rename(
    date = Date,
    daily_price = `Price`
  )
final_price
```

```{r}
# from univariate data, check if there are misisng dates
missing_dates <- final_price %>%
  complete(date = seq.Date(min(date), max(date), by = "day")) %>%
  filter(is.na(daily_price))

length(missing_dates$date)
```

```{r}
# take the monthly average
monthly_avg_price <- final_price %>%
  mutate(year_month = format(date, "%Y-%m")) %>%
  group_by(year_month) %>%
  summarise(avg_price = mean(daily_price, na.rm = TRUE))

monthly_avg_price
tail(monthly_avg_price)
```

```{r}
# select only the date and temperature from final_ghana
final_temp <- final_ghana[, c("Date", "TAVG")]
final_temp
```
```{r}
monthly_avg_temp <- final_temp %>%
  mutate(year_month = format(Date, "%Y-%m")) %>%
  group_by(year_month) %>%
  summarise(avg_temp = mean(TAVG, na.rm = TRUE))

monthly_avg_temp
tail(monthly_avg_temp)
```


```{r}
monthly_avg_temp <- monthly_avg_temp %>%
  mutate(year_month = as.Date(paste0(year_month, "-01")))

# Step 2: Create a complete sequence of months
full_months <- data.frame(
  year_month = seq(min(monthly_avg_temp$year_month),
                   max(monthly_avg_temp$year_month),
                   by = "month")
)

# Step 3: Left join with the original data to insert NAs where data is missing
full_data <- full_months %>%
  left_join(monthly_avg_temp, by = "year_month")

# Step 4: Interpolate missing values
full_data <- full_data %>%
  mutate(avg_temp = na.approx(avg_temp, na.rm = FALSE))

# Step 5: Convert date back to "YYYY-MM" if needed
full_data <- full_data %>%
  mutate(year_month = format(year_month, "%Y-%m"))
monthly_avg_temp <- full_data
monthly_avg_temp
```




```{r}
final_precipitation <- final_ghana[, c("Date", "PRCP")]
final_precipitation
```

```{r}
final_precipitation <- final_precipitation %>%
  mutate(precipitation_binary = if_else(is.na(PRCP), 0, 1))
final_precipitation <- final_precipitation[, c("Date", "precipitation_binary")]
```
```{r}
final_precipitation
```




```{r}
monthly_avg_precipitation <- final_precipitation %>%
  mutate(year_month = format(Date, "%Y-%m")) %>%
  group_by(year_month) %>%
  summarise(precipitation_days = sum(precipitation_binary, na.rm = TRUE))
monthly_avg_precipitation

```

```{r}
monthly_avg_precipitation <- monthly_avg_precipitation %>%
  mutate(year_month = as.Date(paste0(year_month, "-01")))

# Step 2: Create complete sequence of months
full_months <- data.frame(
  year_month = seq(min(monthly_avg_precipitation$year_month),
                   max(monthly_avg_precipitation$year_month),
                   by = "month")
)

# Step 3: Left join and fill missing precipitation_days with 0
full_precip_data <- full_months %>%
  left_join(monthly_avg_precipitation, by = "year_month") %>%
  mutate(precipitation_days = ifelse(is.na(precipitation_days), 0, precipitation_days))

# Step 4: Convert year_month back to "YYYY-MM"
full_precip_data <- full_precip_data %>%
  mutate(year_month = format(year_month, "%Y-%m"))
monthly_avg_precipitation <- full_precip_data
monthly_avg_precipitation
```

```{r}
monthly_avg_price <- monthly_avg_price %>%
  mutate(year_month = as.Date(paste0(year_month, "-01")))

monthly_avg_temp <- monthly_avg_temp %>%
  mutate(year_month = as.Date(paste0(year_month, "-01")))

monthly_avg_precipitation <- monthly_avg_precipitation %>%
  mutate(year_month = as.Date(paste0(year_month, "-01")))
```


```{r}
combined_data <- monthly_avg_price %>%
  inner_join(monthly_avg_temp, by = "year_month") %>%
  inner_join(monthly_avg_precipitation, by = "year_month")
sorted_data <- combined_data
sorted_data
```


```{r}
var_df <- sorted_data
var_df
```

```{r}
#Check for stationary
adf.test(var_df$precipitation_days)
adf.test(var_df$avg_price)
adf.test(var_df$avg_temp)
```

```{r}
# Making it stationary 
var_df <- var_df %>%
  mutate(diff_log_price = c(NA, diff(log(avg_price))))
var_df
```

```{r}
# Get rid of the year with 1994-10-01
var_df <- var_df %>%
  filter(year_month != "1994-10-01")
var_df
```

```{r}
# fidn everything in diff_log_prie that is NA
na_rows <- var_df %>%
  filter(is.na(diff_log_price))
na_rows
```


```{r}
adf.test(var_df$precipitation_days)
adf.test(var_df$diff_log_price)
adf.test(var_df$avg_temp)
```
# All stationary from Above 



```{r}
# keep train data as dates 2023 and before
train_data <- var_df %>%
  filter(year_month < ym("2024-01"))
train_data
```


```{r}
test_data <- var_df %>%
  filter(year_month >= ym("2023-12"))
test_data
```

```{r}
# now do it into the data frame 
train_data <- train_data[, c("diff_log_price", "precipitation_days", "avg_temp")]
train_data
```
```{r}
test_data <- test_data[, c("year_month", "avg_price")]
test_data
```


```{r}
lag_selection <- VARselect(train_data, 
                           lag.max = 12, 
                           type = "both"
                           )
print(lag_selection)
lag_selection$selection
```
# From the AIC we see that the best lag is 12
# lag_selection$selection

```{r}
# Suppose you pick p=12 based on the AIC
p_chosen <- 12
```



```{r}
# 6. Fit the VAR
var_model <- VAR(train_data, p = 12, type = "both")
var_model
summary(var_model)
```

```{r}
var_forecast <- predict(var_model, n.ahead = 11)
var_forecast
```


```{r}
log_price_forecast <- data.frame(fcst = var_forecast$fcst$diff_log_price[, "fcst"])

# View the result
print(log_price_forecast)
```

```{r}
test_ts <- ts(test_data$avg_price, frequency = 12, start = c(2023, 12))
test_ts
```

```{r}
forecasted_price <- exp(log_price_forecast + log(test_ts[1]))
forecasted_price
```


```{r}
forecast_months <- seq(from = as.Date("2024-01-01"), by = "month", length.out = 11)

# Actual values for those forecasted months (from your test_ts)
actual_price <- as.numeric(window(test_ts, start = c(2024, 1), end = c(2024, 11)))

# Combine into a single data frame
comparison_df <- data.frame(
  Month = forecast_months,
  Actual = actual_price,
  Forecast = forecasted_price$fcst
)
```


```{r}
ggplot(comparison_df, aes(x = Month)) +
  geom_line(aes(y = Actual, color = "Actual")) +
  geom_line(aes(y = Forecast, color = "Forecasted")) +
  labs(
    title = "Actual vs Forecasted Prices",
    x = "Month",
    y = "Price",
    color = "Legend"
  ) +
  scale_color_manual(values = c("Actual" = "blue", "Forecasted" = "red")) +
  theme_minimal()
```


















```{r}
forecast_diff_log_price <- forecast$fcst$diff_log_price[, "fcst"]

# 2. Get the last actual log(price)
last_actual_price <- tail(var_df$avg_price[!is.na(var_df$diff_log_price)], 1)
last_actual_price
last_log_price <- log(last_actual_price)

# 3. Reconstruct future log prices
future_log_prices <- cumsum(c(last_log_price, forecast_diff_log_price))

# 4. Convert log prices back to actual prices
future_prices <- exp(future_log_prices[-1])  # Remove the initial known price

# 5. Create forecasted date sequence
future_dates <- seq(max(var_df$year_month) + months(1), by = "month", length.out = length(future_prices))

# 6. Build the forecast dataframe
forecast_df <- data.frame(
  year_month = future_dates,
  forecasted_price = future_prices
)

forecast_df

```

```{r}
ggplot(forecast_df, aes(x = year_month, y = forecasted_price)) +
  geom_line(color = "blue") +
  labs(title = "Forecasted Average Prices",
       x = "Date",
       y = "Forecasted Price")
```






```{r}
# from prices_data, get the actual price from 29/11/2024 to 9/12/2024

prices_data$Date <- as.Date(prices_data$Date, format="%d/%m/%Y")

# Filter dates and select actual_price
filtered_prices <- prices_data[prices_data$Date >= as.Date("29/11/2024", "%d/%m/%Y") & 
                               prices_data$Date <= as.Date("15/12/2024", "%d/%m/%Y"), 
                               c("Date", "Price")]

filtered_prices
```



```{r}
serial_test <- serial.test(var_model, lags.pt = 12, type = "PT.asymptotic")
serial_test
stability(var_model)
plot(stability(var_model))
```




```{r}
# 8. Forecast h steps ahead (e.g. h=30 days)
fc <- predict(var_model, n.ahead = 30)

# Look at log_price forecast
print(fc$fcst$log_price)

# Invert the log transform for actual price predictions
level_price_point_forecast <- exp(fc$fcst$log_price[, "fcst"])

# 9. Visualize log_price forecasts with a fan chart
fanchart(fc, names = "log_price")

```








```{r}
var_train <- var_data[6600:1]

# Refit VAR model on just those 6600 observations
var_model_cut <- VAR(var_train, p = 5, type = "const")


```





















```{r}
forecast_cut <- predict(var_model_cut, n.ahead = 30)
fanchart(forecast_cut, names = "log_price")

actual <- var_data[6601:6630, "log_price"]

# Forecasted mean values
forecasted <- forecast_cut$fcst$log_price[, "fcst"]

# Create data frame to compare
comparison_df <- data.frame(
  day = 6601:6630,
  actual = actual$log_price,
  forecasted = forecasted
)

# Plot
library(ggplot2)
ggplot(comparison_df, aes(x = day)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = forecasted, color = "Forecast")) +
  labs(title = "Actual vs Forecasted (log_price)",
       y = "Log Price", color = "") +
  theme_minimal()

```


```{r}
#
(11/12/2024   | 10136.26 |
| 56  | 10/12/2024   | 10124.83 |
| 57  | 09/12/2024   |  9727.65 |
| 58  | 06/12/2024   |  9462.84 |
| 59  | 05/12/2024   |  9459.13 |
| 60  | 04/12/2024   |  9020.61 |
| 61  | 03/12/2024   |  8720.04 |
| 62  | 02/12/2024   |  9073.31 |
| 63  | 29/11/2024   |  9099.80 |
| 64  | 28/11/2024   |  8956.18 |
```







# 7. Diagnostics
serial_test <- serial.test(var_model, lags.pt = 12, type = "PT.asymptotic")
serial_test
stability(var_model)
plot(stability(var_model))

# 8. Forecast h steps ahead (e.g. h=30 days)
fc <- predict(var_model, n.ahead = 30)

# Look at log_price forecast
print(fc$fcst$log_price)

# Invert the log transform for actual price predictions
level_price_point_forecast <- exp(fc$fcst$log_price[, "fcst"])

# 9. Visualize log_price forecasts with a fan chart
fanchart(fc, names = "log_price")

# (You can also compare to actual future or holdout data to assess errors)











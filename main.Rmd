---
title: "cleaning_data"
output: pdf_document
date: "`r Sys.Date()`"
---

```{r}
# load libraries
library(tidyverse)
library(ggplot2)
library(forecast)
library(lubridate)
library(dplyr)
library(astsa)
library(dplyr)
library(lubridate)
library(vars)
library(forecast)
library(tseries)
```

```{r} 
# load data
prices_data <- read_csv("DailyPrices_ICCO.csv", show_col_types=FALSE)
ghana_data <- read_csv("Ghana_data.csv", show_col_types=FALSE)
```


```{r}
clean_ghana <- ghana_data %>%
  mutate(DATE = ymd(DATE)) %>%
  distinct(DATE, .keep_all = TRUE) %>%
  filter(between(DATE, ymd("1994-10-03"), ymd("2024-11-28"))) %>%
  arrange(DATE)
clean_ghana
```
```{r}
total_duplicates <- sum(duplicated(clean_ghana))
total_duplicates
```
```{r}
# select the columns we needDATE, PRCP, TAVG)
final_ghana <- clean_ghana %>%
  select(DATE, PRCP, TAVG)
final_ghana
```


```{r}
# Load necessary library

# Find rows with duplicated dates
duplicate_dates <- prices_data %>%
  group_by(Date) %>%        # Group by the "Date" column
  filter(n() > 1) %>%       # Keep dates that appear more than once
  arrange(Date) %>%         # Sort by date for clarity
  ungroup()

# Modify the column name from ICCO daily price (US$/tonne) to Price
prices_data <- rename(
  prices_data, 
  Price=`ICCO daily price (US$/tonne)`
)
```

```{r}
# View the results
print(duplicate_dates)

```


```{r}
data <- prices_data %>%
  mutate(Date = ymd(Date)) %>%
  arrange(Date) %>%
  mutate(
    next_price = lead(Price),
    next_date = lead(Date),
    days_diff = as.numeric(next_date - Date),
    price_diff = next_price - Price
  ) %>%
  filter(
    days_diff == 1,          # Strictly consecutive days
    price_diff > 100,        # Price increase > $100
    !is.na(price_diff)       # Remove NA from the last row
  ) %>%
  select(Date, Price, next_date, next_price, price_diff)

# Print results
if (nrow(data) == 0) {
  message("No rows met the criteria.")
} else {
  print(data)
}

```


```{r}
clean_price <- prices_data %>%
  distinct() %>%
  filter(!(Date == "30/01/2024" & `Price` == 10676.42)) %>%
  filter(!(Date == "31/01/2024" & `Price` == 10888.05))
```

```{r}
# Load necessary library

# Find rows with duplicated dates
duplicate_dates <- clean_price %>%
  group_by(Date) %>%        # Group by the "Date" column
  filter(n() > 1) %>%       # Keep dates that appear more than once
  arrange(Date) %>%         # Sort by date for clarity
  ungroup()

print(duplicate_dates)

```


```{r}
final_price <- clean_price %>%
  select(Date, `Price`)

```


```{r}
final_price <- final_price %>%
  mutate(Date = as.Date(Date, format = "%d/%m/%Y"))

# Ensure DATE column is already Date type (if not, convert)
final_ghana <- final_ghana %>%
  mutate(DATE = as.Date(DATE))

```



```{r}
combined_data <- final_price %>%
  inner_join(final_ghana, by = c("Date" = "DATE"))

combined_data
```
```{r}
sorted_data <- combined_data %>%
  mutate(Date = ymd(Date)) %>%       # Convert to proper date format
  arrange(Date) %>%                 # Sort by ascending date
  select(Date, everything())        # Ensure date column comes first

# View sorted data
sorted_data

```
```{r}
sorted_data <- sorted_data %>%
  rename(
    date = Date,
    daily_price = `Price`,  
    precipitation = PRCP,                               
    avg_temperature = TAVG                             
  )

```

```{r}
sorted_data
```

```{r}
sorted_data <- sorted_data %>%
  mutate(precipitation_binary = if_else(is.na(precipitation), 0, 1))

```

```{r}
sorted_data
```
```{r}
sorted_data <- sorted_data %>%
  select(date, daily_price, precipitation_binary, avg_temperature)
```

```{r}
sorted_data <- sorted_data %>%
  rename(
    precipitation = precipitation_binary
  )

```


```{r}
sorted_data
```


```{r}
var_df <- sorted_data 
var_df
```


```{r}
adf.test(var_df$precipitation)
adf.test(var_df$daily_price)
adf.test(var_df$avg_temperature)
```

```{r}
var_df <- var_df %>%
  mutate(diff_log_price = c(NA, diff(log(daily_price))))
var_df
```

```{r}
# get rid of 1994-10-03 row
var_df <- var_df %>%
  filter(date != ymd("1994-10-03"))

tail(var_df) 


```
```{r}
# fidn everything in diff_log_prie that is NA
na_rows <- var_df %>%
  filter(is.na(diff_log_price))
na_rows
```



```{r}
adf.test(var_df$precipitation)
adf.test(var_df$diff_log_price)
adf.test(var_df$avg_temperature)
```
# All stationary from Above 




```{r}
# now do it into the data frame 
var_data <- var_df %>%
  select(diff_log_price, precipitation, avg_temperature) %>%
  as.data.frame()
var_data
```

```{r}
lag_selection <- VARselect(var_data, 
                           lag.max = 10, 
                           type = "both"
                           )
print(lag_selection)
```

```{r}
# Suppose you pick p=3
p_chosen <- 3
```



```{r}
# 6. Fit the VAR
var_model <- VAR(var_data, p = p_chosen, type = "both")
summary(var_model)
```

```{r}
#I want to plot starting from 6600 days
forecast <- predict(var_model)
```

```{r}
forecasted_log_diff_price <- forecast$fcst$diff_log_price[,1]
#undiiference the forecasted log price
forecasted_log_price <- cumsum(c(log(sorted_data$daily_price[6600])) + forecasted_log_diff_price)
forecasted_price <- exp(forecasted_log_price)

forecasted_price <- as.numeric(forecasted_price)
forecasted_price
# plot the forecasted price
plot(forecasted_price, type = "l", col = "blue", xlab = "Days", ylab = "Price", main = "Forecasted Price")
```

```{r}
# Find actual price from 11-28-2025 to 12-10-2024
prices_data %>%
  filter(Date >= "28/11/2024" & Date <= "10/12/2024") %>%
  select(Date, Price)
```

```{r}
clean_price <- prices_data %>%
  distinct() %>%
  filter(!(Date >= "30/01/2024" & `Price` == 10676.42)) %>%
  filter(!(Date == "31/01/2024" & `Price` == 10888.05))

plot(forecast)

```







```{r}
var_train <- var_data[1:6600, ]

# Refit VAR model on just those 6600 observations
var_model_cut <- VAR(var_train, p = 5, type = "const")


```


```{r}
forecast_cut <- predict(var_model_cut, n.ahead = 30)
fanchart(forecast_cut, names = "log_price")

actual <- var_data[6601:6630, "log_price"]

# Forecasted mean values
forecasted <- forecast_cut$fcst$log_price[, "fcst"]

# Create data frame to compare
comparison_df <- data.frame(
  day = 6601:6630,
  actual = actual$log_price,
  forecasted = forecasted
)

# Plot
library(ggplot2)
ggplot(comparison_df, aes(x = day)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = forecasted, color = "Forecast")) +
  labs(title = "Actual vs Forecasted (log_price)",
       y = "Log Price", color = "") +
  theme_minimal()

```


```{r}
#
(11/12/2024   | 10136.26 |
| 56  | 10/12/2024   | 10124.83 |
| 57  | 09/12/2024   |  9727.65 |
| 58  | 06/12/2024   |  9462.84 |
| 59  | 05/12/2024   |  9459.13 |
| 60  | 04/12/2024   |  9020.61 |
| 61  | 03/12/2024   |  8720.04 |
| 62  | 02/12/2024   |  9073.31 |
| 63  | 29/11/2024   |  9099.80 |
| 64  | 28/11/2024   |  8956.18 |
```







# 7. Diagnostics
serial_test <- serial.test(var_model, lags.pt = 12, type = "PT.asymptotic")
serial_test
stability(var_model)
plot(stability(var_model))

# 8. Forecast h steps ahead (e.g. h=30 days)
fc <- predict(var_model, n.ahead = 30)

# Look at log_price forecast
print(fc$fcst$log_price)

# Invert the log transform for actual price predictions
level_price_point_forecast <- exp(fc$fcst$log_price[, "fcst"])

# 9. Visualize log_price forecasts with a fan chart
fanchart(fc, names = "log_price")

# (You can also compare to actual future or holdout data to assess errors)










